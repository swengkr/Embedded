ESP32-C3 Super Mini & ë¬´ì„ (WiFi) ê¸°ë°˜ ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¬ë°(RTP)ì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

### êµ¬ì„± ìš”ì†Œ & ìŠ¤í™
- MCU ëª¨ë“ˆ : ESP32-C3 Super Mini
- DAC : PCM5102A (I2S)
- Streaming Server : GStreamer (Windows)
- Streaming Protocol : RTP (UDP)
- Audio Codec. : OPUS (mediumband)
- Audio Source : MP3 (Generated by TTS)
- Audio Amplifer : TDA2030A (Mono, 18W)
- Graphic Equalizer : LED Bar
- Speaker

> ğŸ’¬ ì´ë¯¸ì§€ í´ë¦­ ì‹œ ìœ íˆ¬ë¸Œ ì˜ìƒ ì¬ìƒ
[![](https://github.com/swengkr/Embedded/blob/main/ESP32/AudioStreaming/project.png)](https://youtube.com/shorts/i4WvUcjz7jY)

### íšŒë¡œ ê²°ì„ ë„
[![](https://github.com/swengkr/Embedded/blob/main/ESP32/AudioStreaming/circuit_diagram.png)](https://youtube.com/shorts/i4WvUcjz7jY)

### ìŠ¤íŠ¸ë¦¬ë° ì„œë²„ ì‹¤í–‰ ëª…ë ¹
```shell
gst-launch-1.0 filesrc location=d:/temp/sample5.mp3 ! decodebin ! queue ! audioconvert ! volume volume=0.1 ! audioresample ! opusenc inband-fec=true frame-size=20 bandwidth="mediumband" ! rtpopuspay pt=96 ! udpsink host=192.168.219.101 port=5004
```

### ESP32-C3 ì†ŒìŠ¤ ì½”ë“œ (Arduino)
```cpp
#include <ESP_I2S.h>
#include <opus.h>
#include <WiFi.h>
#include <WiFiUdp.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <freertos/queue.h>
#include <math.h>

// I2S í•€ ì„¤ì • (DAC/AMP ì—°ê²°) - GPIO 5, 6, 9
#define I2S_BCLK 5 // CLOCK : I2S í´ëŸ­ (BCLK)
#define I2S_DIN  6 // Serial Data In : I2S ì˜¤ë””ì˜¤ ë°ì´í„° ì…ë ¥
#define I2S_LRC  9 // Word Select : ì¢Œ/ìš° ì±„ë„ ì„ íƒ (LRCK)

// LED GPIO í•€ ì„¤ì • (5-ë°´ë“œ ì´í€„ë¼ì´ì €)
const int LED_PINS[] = {0, 1, 7, 8, 10}; // Bass, Low-Mid, Mid, High-Mid, Treble
const int NUM_LEDS = 5;

// Opus í‘œì¤€ ìƒ˜í”Œ ë ˆì´íŠ¸
const int sampleRate = 48000;
#define PI 3.14159265358979323846

// ---------- WiFi ì„¤ì • ----------
const char* ssid = "******";
const char* password = "******";

// ---------- RTP ìˆ˜ì‹  ì„¤ì • ----------
WiFiUDP udp;
const uint16_t RTP_PORT = 5004;

// ---------- OPUS ì„¤ì • ----------
#define MAX_PACKET_SIZE 1500
OpusDecoder* opusDecoder;
const int channels = 2;  // stereo
// 20ms í”„ë ˆì„(960 ìƒ˜í”Œ) ìœ ì§€
const int frameSize = 960; 
int16_t pcmBuffer[frameSize * channels];

// ---------- FreeRTOS Queue ì„¤ì • ----------
#define QUEUE_SIZE 30 
#define STARTUP_FILL_LEVEL 10 
struct OpusPacket {
  uint8_t data[MAX_PACKET_SIZE - 12];
  int len;
};
QueueHandle_t opusQueue;
TaskHandle_t audioTaskHandle = NULL;
void audio_task(void *param);

i2s_data_bit_width_t bps = I2S_DATA_BIT_WIDTH_16BIT;
i2s_mode_t mode = I2S_MODE_STD;
i2s_slot_mode_t slot = I2S_SLOT_MODE_STEREO;

I2SClass i2s;

// ---------- EQ í•„í„° ë° ìƒíƒœ ë³€ìˆ˜ ----------
// CPU ë¶€í•˜ë¥¼ ì¤„ì´ê¸° ìœ„í•œ ê°„ë‹¨í•œ ì €ì—­ í†µê³¼ í•„í„° (EMA)
float bass_lp_ema = 0.0f;
float mid_lp_ema = 0.0f; // ì¤‘ê°„ ì£¼íŒŒìˆ˜ ë¶„ë¦¬ë¥¼ ìœ„í•´ ì¶”ê°€
// LEDì˜ í”¼í¬ ë ˆë²¨ì„ ì¶”ì í•˜ëŠ” ë³€ìˆ˜ (ì”ìƒ íš¨ê³¼)
float visual_decay[NUM_LEDS] = {0.0f};

// Low-Pass í•„í„° ìƒìˆ˜ (Bass) - ëŠë¦° ë°˜ì‘
const float BASS_ALPHA = 0.05f; 
// Mid-Pass í•„í„° ìƒìˆ˜ - ì¤‘ê°„ ë°˜ì‘
const float MID_ALPHA = 0.15f; 
// Decay ìƒìˆ˜ (LED ë°ê¸° ê°ì†Œ ì†ë„) - ì”ìƒì„ ëŠ˜ë¦¼
const float DECAY_ALPHA = 0.5f; 
// ê²Œì¸ ì¡°ì ˆ (ê°ë„) - 10ë°° ìƒí–¥ ì¡°ì •í•˜ì—¬ LED ë°˜ì‘ì„± ê·¹ëŒ€í™”
const float GAIN_FACTOR = 0.000005f; 

// ë””ì§€í„¸ ì¶œë ¥ ì„ê³„ê°’ (0.0 ~ 1.0 ìŠ¤ì¼€ì¼): ê°’ì´ í¬ë©´ ë” ê°•í•œ ì†Œë¦¬ì—ë§Œ ë°˜ì‘
const float DIGITAL_THRESHOLD = 0.2f; 

/
 * @brief PCM ë°ì´í„°ì˜ RMS(ì œê³± í‰ê·  ì œê³±ê·¼) ì—ë„ˆì§€ ê³„ì‚°
 * @param pcm PCM ë°ì´í„° ë²„í¼ (int16_t)
 * @param num_samples ìƒ˜í”Œ ìˆ˜ (ìŠ¤í…Œë ˆì˜¤ì´ë¯€ë¡œ ì±„ë„ ìˆ˜ * í”„ë ˆì„ ì‚¬ì´ì¦ˆ)
 * @return ì—ë„ˆì§€ ê°’ (float)
 */
float calculate_energy(int16_t* pcm, int num_samples) {
    long long sum_sq = 0;
    for (int i = 0; i < num_samples; i++) {
        sum_sq += (long long)pcm[i] * pcm[i];
    }
    // RMS ëŒ€ì‹  Sum of Squaresë¥¼ ì‚¬ìš©, ì—ë„ˆì§€ì— ë¹„ë¡€
    return (float)sum_sq / num_samples; 
}

/
 * @brief ì˜¤ë””ì˜¤ ì—ë„ˆì§€ì— ë”°ë¼ 5ê°œ LEDì˜ ë°ê¸° ì—…ë°ì´íŠ¸. (ë””ì§€í„¸ On/Off ë°©ì‹)
 * @param pcm ë””ì½”ë”©ëœ PCM ë°ì´í„° ë²„í¼
 * @param frame_len ë””ì½”ë”©ëœ ìƒ˜í”Œ ìˆ˜ (960)
*/
void update_equalizer_leds(int16_t* pcm, int frame_len) {
    // í˜„ì¬ í”„ë ˆì„ì˜ ì´ ì—ë„ˆì§€ ê³„ì‚° (ìŠ¤í…Œë ˆì˜¤ì´ë¯€ë¡œ 2 * frame_len)
    float current_energy = calculate_energy(pcm, frame_len * channels);
    
    // EMA í•„í„° ì—…ë°ì´íŠ¸
    // Bass (ì €ì—­ í†µê³¼) EMA ì—…ë°ì´íŠ¸ (ëŠë¦¼)
    bass_lp_ema = bass_lp_ema * (1.0f - BASS_ALPHA) + current_energy * BASS_ALPHA;
    // Mid (ì¤‘ì—­ í†µê³¼) EMA ì—…ë°ì´íŠ¸ (ì¤‘ê°„ ì†ë„)
    mid_lp_ema = mid_lp_ema * (1.0f - MID_ALPHA) + current_energy * MID_ALPHA;
    
    // ê° ë°´ë“œì— ì—ë„ˆì§€ í• ë‹¹ (ì°¨ë¶„ ê¸°ë°˜ ì£¼íŒŒìˆ˜ ë¶„ë¦¬)
    float bands[NUM_LEDS];

    // Band 0: Bass (ëŠë¦° EMA ìì²´)
    bands[0] = bass_lp_ema * 1.5f;   

    // Band 1: Low-Mid (ì¤‘ê°„ EMA - ëŠë¦° EMA)
    bands[1] = (mid_lp_ema - bass_lp_ema) * 3.0f; 
    if (bands[1] < 0) bands[1] = 0;

    // Band 2, 3, 4: Mid, High-Mid, Treble (ì´ ì—ë„ˆì§€ - ì¤‘ê°„ EMA = ì”ì—¬ ê³ ì£¼íŒŒ ì—ë„ˆì§€)
    float remaining_high_energy = current_energy - mid_lp_ema;
    if (remaining_high_energy < 0) remaining_high_energy = 0;

    // ì”ì—¬ ì—ë„ˆì§€ë¥¼ Mid-High ë°´ë“œì— ë¶„ë°°í•˜ê³  ê²Œì¸ ì ìš©
    bands[2] = remaining_high_energy * 0.2f * 4.0f; // Mid
    bands[3] = remaining_high_energy * 0.3f * 4.0f; // High-Mid
    bands[4] = remaining_high_energy * 0.5f * 4.0f; // Treble

    // LED ì¶œë ¥
    for (int i = 0; i < NUM_LEDS; i++) {
        // ì—ë„ˆì§€ ê°’ì— ì „ì²´ GAIN_FACTOR ì ìš©
        float raw_value = bands[i] * GAIN_FACTOR;
        
        // ì‹œê°ì  ì”ìƒ íš¨ê³¼ (Decay) ì ìš©: í”¼í¬ ë ˆë²¨ ì¶”ì 
        if (raw_value > visual_decay[i]) {
            visual_decay[i] = raw_value; // Peak Attack
        } else {
            visual_decay[i] *= DECAY_ALPHA; // Peak Decay
        }

        // Decay ë ˆë²¨ì´ ì„ê³„ê°’ì„ ì´ˆê³¼í•˜ë©´ LED ì¼œê¸° (HIGH)
        if (visual_decay[i] > DIGITAL_THRESHOLD) {
            digitalWrite(LED_PINS[i], HIGH);
        } else {
            digitalWrite(LED_PINS[i], LOW);
        }
    }
}

/
 * @brief LED GPIO ì´ˆê¸°í™” í•¨ìˆ˜ (ë””ì§€í„¸ ì¶œë ¥)
*/
void led_setup() {
    for (int i = 0; i < NUM_LEDS; i++) {
        pinMode(LED_PINS[i], OUTPUT);
        digitalWrite(LED_PINS[i], LOW); // ì´ˆê¸°í™” ì‹œ LED ë„ê¸°
    }
}

void setup() {
  Serial.begin(115200);
  Serial.println("I2S Opus RTP Receiver");

  // I2S í•€ ì„¤ì •
  i2s.setPins(I2S_BCLK, I2S_LRC, I2S_DIN);
  
  // LED GPIO ì´ˆê¸°í™” (ë””ì§€í„¸ ì¶œë ¥ ì‚¬ìš©)
  led_setup();

  // WiFi ì—°ê²°
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.print("[WiFi] Connecting...");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\n[WiFi] Connected!");
  Serial.print("[WiFi] IP: ");
  Serial.println(WiFi.localIP());

  // UDP ë°”ì¸ë“œ
  if (!udp.begin(RTP_PORT)) {
    Serial.println("[UDP] Failed to start UDP!");
    while (1);
  }
  Serial.printf("[UDP] Listening on port %d\n", RTP_PORT);

  // I2S ì‹œì‘: 48000 Hz, 16-bits, Stereo
  if (!i2s.begin(mode, sampleRate, bps, slot)) {
    Serial.println("Failed to initialize I2S!");
    while (1);  // do nothing
  }
  Serial.printf("[I2S] Initialized at %d Hz\n", sampleRate);

  // OPUS ë””ì½”ë” ì´ˆê¸°í™”
  int err;
  opusDecoder = opus_decoder_create(sampleRate, channels, &err);
  if (err != OPUS_OK) {
    Serial.printf("[Opus] Decoder init failed: %d (Check sample rate!)\n", err);
    while (1);
  }
  Serial.println("[Opus] Decoder initialized");

  // FreeRTOS í ìƒì„±
  opusQueue = xQueueCreate(QUEUE_SIZE, sizeof(OpusPacket));
  if (opusQueue == NULL) {
    Serial.println("[FreeRTOS] Failed to create Opus queue!");
    while (1);
  }
  
  // ìŠ¤íƒ í¬ê¸° ë° ìš°ì„ ìˆœìœ„ ì„¤ì •
  xTaskCreate(audio_task, "AudioTask", 16384, NULL, 20, &audioTaskHandle); 
  Serial.println("[FreeRTOS] Audio task started.");
}

// ì˜¤ë””ì˜¤ ë””ì½”ë”©, I2S ì“°ê¸°, EQ ì—…ë°ì´íŠ¸ ì „ìš© FreeRTOS íƒœìŠ¤í¬
void audio_task(void *param) {
  OpusPacket incomingPacket;

  // 1. ì‹œì‘ ì‹œ ì§€í„° ë²„í¼ ì±„ìš°ê¸° (Pre-fill Delay)
  Serial.printf("[AudioTask] Waiting for initial %d packets...\n", STARTUP_FILL_LEVEL);
  for (int i = 0; i < STARTUP_FILL_LEVEL; i++) {
    if (xQueueReceive(opusQueue, &incomingPacket, portMAX_DELAY) == pdPASS) {
      int frameCount = opus_decode(opusDecoder, incomingPacket.data, incomingPacket.len, pcmBuffer, frameSize, 0);

      if (frameCount > 0) {
        size_t bytesToWrite = frameCount * channels * sizeof(int16_t);
        i2s.write((const uint8_t*)pcmBuffer, bytesToWrite);
        
        // ì´ˆê¸° ë²„í¼ ì±„ìš°ê¸° ë‹¨ê³„ì—ì„œë„ EQ ì—…ë°ì´íŠ¸ ìˆ˜í–‰
        update_equalizer_leds(pcmBuffer, frameCount); 
      }
    } else {
      Serial.println("[AudioTask] Error during initial fill!");
      break;
    }
  }
  Serial.println("[AudioTask] Playback started.");
  
  // 2. ì£¼ ì¬ìƒ ë£¨í”„
  while (1) {
    if (xQueueReceive(opusQueue, &incomingPacket, portMAX_DELAY) == pdPASS) {
      int frameCount = opus_decode(opusDecoder, incomingPacket.data, incomingPacket.len, pcmBuffer, frameSize, 0);
      if (frameCount > 0) {
        // I2Sì— ì“°ê¸°
        size_t bytesToWrite = frameCount * channels * sizeof(int16_t);
        size_t bytes_written = i2s.write((const uint8_t*)pcmBuffer, bytesToWrite);
        
        if (bytes_written != bytesToWrite) {
          Serial.printf("[I2S] WARNING: Wrote only %u of %u bytes (Underrun).\n", bytes_written, bytesToWrite);
        }

        // EQ ì‹œê°í™” í•¨ìˆ˜ í˜¸ì¶œ
        update_equalizer_leds(pcmBuffer, frameCount);
      } else {
        Serial.printf("[Opus] Decode error: %d\n", frameCount);
      }
      
      // CPU ì–‘ë³´ (ë‹¤ë¥¸ ì‹œìŠ¤í…œ íƒœìŠ¤í¬ë¥¼ ìœ„í•´)
      taskYIELD(); 
    }
  }
  vTaskDelete(NULL); 
}

void loop() {
  static uint8_t packet[MAX_PACKET_SIZE];

  int packetSize = udp.parsePacket();
  if (packetSize > 0) {
    int len = udp.read(packet, MAX_PACKET_SIZE);
    
    // RTP í—¤ë”(12ë°”ì´íŠ¸) í™•ì¸
    if (len > 12) {
      OpusPacket newPacket;
      
      int opusLen = len - 12;
      int dataToCopy = min(opusLen, (int)sizeof(newPacket.data)); 

      memcpy(newPacket.data, packet + 12, dataToCopy);
      newPacket.len = dataToCopy;

      // ì˜¤ë””ì˜¤ íƒœìŠ¤í¬ íë¡œ íŒ¨í‚· ì „ì†¡
      if (xQueueSend(opusQueue, &newPacket, 0) != pdPASS) {
        Serial.println("[Queue] Warning: Audio queue full (Packet dropped)");
      }
    }
  }
}
```

### TTS ìŒì› ìƒì„± ì†ŒìŠ¤ ì½”ë“œ (Python)
```python
import asyncio
#Microsoft Edge TTS ì‚¬ìš©
import edge_tts

TEXT = "ìƒì„±í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”."
#VOICE = "ko-KR-InJoonNeural"  # í•œêµ­ì–´ ë‚¨ì„± ìŒì„±
VOICE = "ko-KR-SunHiNeural"  # í•œêµ­ì–´ ì—¬ì„± ìŒì„±
OUTPUT = "tts_output.mp3"

async def main():
    communicate = edge_tts.Communicate(TEXT, VOICE)
    await communicate.save(OUTPUT)
    print(f"[ì™„ë£Œ] {OUTPUT} íŒŒì¼ ìƒì„±ë¨")

asyncio.run(main())
```
